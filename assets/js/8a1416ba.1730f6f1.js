"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[7699],{5427:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"concepts/architecture","title":"Architecture","description":"Learn how Bethrou architecture works: client-node communication, libp2p integration, PSK security, NAT traversal, and routing strategies for decentralized proxy networks.","source":"@site/docs/concepts/architecture.md","sourceDirName":"concepts","slug":"/concepts/architecture","permalink":"/docs/concepts/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/bethrou/bethrou/tree/main/docs/docs/concepts/architecture.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Architecture","description":"Learn how Bethrou architecture works: client-node communication, libp2p integration, PSK security, NAT traversal, and routing strategies for decentralized proxy networks.","keywords":["architecture","p2p","libp2p","proxy network","SOCKS5","NAT traversal","network design"],"image":"../../img/bethrou-icon.svg"},"sidebar":"docsSidebar","previous":{"title":"NAT Traversal","permalink":"/docs/guides/nat-traversal"},"next":{"title":"Security & Privacy","permalink":"/docs/concepts/security"}}');var r=i(4848),s=i(8453);const o={sidebar_position:1,title:"Architecture",description:"Learn how Bethrou architecture works: client-node communication, libp2p integration, PSK security, NAT traversal, and routing strategies for decentralized proxy networks.",keywords:["architecture","p2p","libp2p","proxy network","SOCKS5","NAT traversal","network design"],image:"../../img/bethrou-icon.svg"},l="Architecture",c={},d=[{value:"System Overview",id:"system-overview",level:2},{value:"Components",id:"components",level:2},{value:"1. Client",id:"1-client",level:3},{value:"2. Node (Exit Node)",id:"2-node-exit-node",level:3},{value:"3. Discovery Service (Optional)",id:"3-discovery-service-optional",level:3},{value:"Network Architecture",id:"network-architecture",level:2},{value:"Private Network Layer",id:"private-network-layer",level:2},{value:"Communication Flow",id:"communication-flow",level:2},{value:"1. Connection Establishment",id:"1-connection-establishment",level:3},{value:"2. Proxy Request",id:"2-proxy-request",level:3},{value:"Routing Strategies",id:"routing-strategies",level:2},{value:"Random",id:"random",level:3},{value:"Round-Robin",id:"round-robin",level:3},{value:"Fastest",id:"fastest",level:3},{value:"NAT Traversal",id:"nat-traversal",level:2},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Trust Model",id:"trust-model",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Latency",id:"latency",level:3},{value:"Throughput",id:"throughput",level:3},{value:"Scalability",id:"scalability",level:3},{value:"Next Steps",id:"next-steps",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"architecture",children:"Architecture"})}),"\n",(0,r.jsx)(n.p,{children:"This document explains the architecture and components of Bethrou."}),"\n",(0,r.jsx)(n.h2,{id:"system-overview",children:"System Overview"}),"\n",(0,r.jsx)(n.p,{children:"Bethrou consists of two main components that communicate over a peer-to-peer network:"}),"\n",(0,r.jsx)(n.mermaid,{value:"flowchart LR\n  A[Your Device\\nApplication] -- SOCKS5 --\x3e B[Bethrou Client]\n  B -- libp2p --\x3e C[Bethrou Node\\nExit Node Server]\n  C --\x3e D[Internet\\nexample.com:443]"}),"\n",(0,r.jsx)(n.h2,{id:"components",children:"Components"}),"\n",(0,r.jsx)(n.h3,{id:"1-client",children:"1. Client"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"Bethrou Client"})," runs on the user's device and provides a SOCKS5 proxy interface."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Responsibilities:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Accept SOCKS5 connections from local applications"}),"\n",(0,r.jsx)(n.li,{children:"Maintain connections to one or more exit nodes"}),"\n",(0,r.jsx)(n.li,{children:"Route proxy requests to appropriate exit nodes based on strategy"}),"\n",(0,r.jsx)(n.li,{children:"Handle connection pooling and health checks"}),"\n",(0,r.jsx)(n.li,{children:"Discover new nodes (via Redis or static configuration)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-node-exit-node",children:"2. Node (Exit Node)"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"Bethrou Node"})," runs on a server and acts as an exit point for proxied traffic."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Responsibilities:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Listen for incoming libp2p connections from clients"}),"\n",(0,r.jsx)(n.li,{children:"Accept proxy requests via custom protocol over libp2p streams"}),"\n",(0,r.jsx)(n.li,{children:"Establish TCP connections to destination addresses"}),"\n",(0,r.jsx)(n.li,{children:"Forward traffic bidirectionally between client and destination"}),"\n",(0,r.jsx)(n.li,{children:"Optionally act as a relay node for NAT traversal"}),"\n",(0,r.jsx)(n.li,{children:"Publish presence to discovery service (Redis)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-discovery-service-optional",children:"3. Discovery Service (Optional)"}),"\n",(0,r.jsxs)(n.p,{children:["Uses ",(0,r.jsx)(n.strong,{children:"Redis pub/sub"})," for dynamic node discovery."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"How it works:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Nodes publish their peer ID and addresses to a Redis topic"}),"\n",(0,r.jsx)(n.li,{children:"Clients subscribe to the topic and discover available nodes"}),"\n",(0,r.jsx)(n.li,{children:"Clients maintain a dynamic list of exit nodes"}),"\n",(0,r.jsx)(n.li,{children:"Health checks remove unresponsive nodes"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"network-architecture",children:"Network Architecture"}),"\n",(0,r.jsx)(n.h2,{id:"private-network-layer",children:"Private Network Layer"}),"\n",(0,r.jsxs)(n.p,{children:["Bethrou uses ",(0,r.jsx)(n.strong,{children:"pre-shared keys (PSK)"})," to create isolated libp2p networks:"]}),"\n",(0,r.jsx)(n.mermaid,{value:"flowchart TB\n  subgraph PSK[libp2p Private Network with PSK]\n    CA[Client A]\n    CB[Client B]\n    N1[Node 1]\n    N2[Node 2]\n    R[Relay Node]\n    CA --- N1\n    N1 --- N2\n    CB --- R\n    R --- N1\n  end\n  classDef small font-size:12px;"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Security Properties:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Only peers with the correct PSK can join the network"}),"\n",(0,r.jsx)(n.li,{children:"libp2p transport encryption (TLS/Noise) protects data in transit"}),"\n",(0,r.jsx)(n.li,{children:"Network is isolated from the public DHT"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"communication-flow",children:"Communication Flow"}),"\n",(0,r.jsx)(n.h3,{id:"1-connection-establishment",children:"1. Connection Establishment"}),"\n",(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n  participant Client\n  participant Node\n  Client->>Node: libp2p connect (PSK auth)\n  Node--\x3e>Client: Connection established\n  Client->>Node: keep-alive / ping\n  Node--\x3e>Client: pong"}),"\n",(0,r.jsx)(n.h3,{id:"2-proxy-request",children:"2. Proxy Request"}),"\n",(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n  participant Client\n  participant Node\n  participant Internet\n  Client->>Node: Proxy Request (target: example.com:443)\n  Node->>Internet: TCP Connect to example.com:443\n  Internet--\x3e>Node: Connection OK\n  Node--\x3e>Client: Proxy Response (OK)\n  Client->>Node: Application Data\n  Node->>Internet: Forward Data\n  Internet--\x3e>Node: Response Data\n  Node--\x3e>Client: Forward Response"}),"\n",(0,r.jsx)(n.h2,{id:"routing-strategies",children:"Routing Strategies"}),"\n",(0,r.jsx)(n.p,{children:"Clients can use different strategies to select exit nodes:"}),"\n",(0,r.jsx)(n.h3,{id:"random",children:"Random"}),"\n",(0,r.jsx)(n.p,{children:"Selects a random healthy node for each connection."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros:"})," Simple, good load distribution\n",(0,r.jsx)(n.strong,{children:"Cons:"})," No optimization for performance"]}),"\n",(0,r.jsx)(n.h3,{id:"round-robin",children:"Round-Robin"}),"\n",(0,r.jsx)(n.p,{children:"Rotates through available nodes in order."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros:"})," Fair distribution, predictable\n",(0,r.jsx)(n.strong,{children:"Cons:"})," May route to slower nodes"]}),"\n",(0,r.jsx)(n.h3,{id:"fastest",children:"Fastest"}),"\n",(0,r.jsx)(n.p,{children:"Selects the node with the lowest latency."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Pros:"})," Best performance\n",(0,r.jsx)(n.strong,{children:"Cons:"})," All traffic may route through one node"]}),"\n",(0,r.jsx)(n.h2,{id:"nat-traversal",children:"NAT Traversal"}),"\n",(0,r.jsx)(n.p,{children:"Bethrou supports NAT traversal through relay nodes:"}),"\n",(0,r.jsx)(n.mermaid,{value:"flowchart LR\n  Client[Client behind NAT] --\x3e|Connect via relay| Relay[Relay public]\n  Relay --\x3e|Circuit Relay| Node[Node behind NAT]\n  Relay --\x3e|Traffic flows through relay| Client"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"How it works:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Relay nodes run with ",(0,r.jsx)(n.code,{children:"--relay-mode"})," flag"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Clients and nodes behind NAT connect to relay"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Relay facilitates connection between NAT'd peers"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Once connected, data flows through relay (circuit relay)"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"trust-model",children:"Trust Model"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clients trust nodes"}),": Exit nodes can observe all proxied traffic"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nodes trust clients"}),": Nodes forward traffic for authenticated clients"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"PSK provides authentication"}),": Only holders of the network key can participate"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trust your exit nodes"}),": Only use nodes you control or trust"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use HTTPS"}),": Exit nodes cannot decrypt HTTPS traffic"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rotate PSK"}),": Change network keys periodically"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitor nodes"}),": Track which nodes are active in your network"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Limit access"}),": Don't share PSK with untrusted parties"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,r.jsx)(n.h3,{id:"latency",children:"Latency"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Total Latency = Client \u2192 Node + Node \u2192 Destination\n\nTypical overhead: 10-50ms depending on:\n- Physical distance to exit node\n- libp2p transport type (TCP, QUIC, WebRTC)\n- Network conditions\n"})}),"\n",(0,r.jsx)(n.h3,{id:"throughput",children:"Throughput"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Limited by"}),": Slowest link in the chain"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bottleneck"}),": Usually the exit node's internet connection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Connection pooling"}),": Reuses libp2p streams for efficiency"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"scalability",children:"Scalability"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clients"}),": Can connect to multiple nodes for redundancy"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nodes"}),": Can handle hundreds of concurrent clients"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Discovery"}),": Redis pub/sub scales to thousands of nodes"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Review ",(0,r.jsx)(n.a,{href:"/docs/concepts/security",children:"security model"})]}),"\n",(0,r.jsxs)(n.li,{children:["Check out ",(0,r.jsx)(n.a,{href:"/docs/guides/configuration",children:"configuration guide"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);